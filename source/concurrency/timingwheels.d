/// taken from https://github.com/ikod/timingwheels
/// license: BSL-1.0
/+
 Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the Software is furnished to do so, all subject to the following:

The copyright notices in the Software and this entire statement, including the above license grant, this restriction and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all derivative works of the Software, unless such copies or derivative works are solely in the form of machine-executable object code generated by a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 +/
module concurrency.timingwheels;

import std.datetime;
import std.exception;
import std.typecons;
import std.format;
import std.traits;
import std.range;
import std.algorithm;
import std.experimental.logger;

import std.experimental.allocator;
import std.experimental.allocator.mallocator : Mallocator;

import core.thread;
import core.memory;

import concurrency.data.hashmap.simple;
import std.typecons : Nullable, nullable;

private class Timer {
	static ulong _current_id;
	private {
		ulong _id;
	}

	this() @safe @nogc {
		_id = _current_id;
		_current_id++;
	}

	~this() @safe @nogc {}

	ulong id() @safe @nogc {
		return _id;
	}

	override string toString() {
		return "%d".format(_id);
	}
}

///
/// scheduling error occurs at schedule() when ticks == 0 or timer already scheduled.
///
///
class ScheduleTimerError : Exception {
	///
	this(string msg, string file = __FILE__, size_t line = __LINE__) @nogc
			@safe {
		super(msg, file, line);
	}
}

///
/// Cancel timer error occurs if you try to cancel timer which is not scheduled.
///
class CancelTimerError : Exception {
	///
	this(string msg, string file = __FILE__, size_t line = __LINE__) @nogc
			@safe {
		super(msg, file, line);
	}
}

///
/// Advancing error occurs if number of ticks for advance not in range 0<t<=256
///
class AdvanceWheelError : Exception {
	///
	///
	///
	this(string msg, string file = __FILE__, size_t line = __LINE__) @nogc
			@safe {
		super(msg, file, line);
	}
}

pragma(inline)
private void dl_insertFront(L)(L* le, L** head) {
	if (*head == null) {
		le.next = le.prev = le;
	} else {
		auto curr_head = *head;
		le.prev = curr_head.prev;
		le.next = curr_head;
		curr_head.prev.next = le;
		curr_head.prev = le;
	}

	*head = le;
}

pragma(inline)
private void dl_unlink(L)(L* le, L** head) in(*head != null) {
	if (le.next == le && *head == le) {
		*head = null;
		return;
	}

	if (le == *head) {
		*head = le.next;
	}

	le.next.prev = le.prev;
	le.prev.next = le.next;
}

pragma(inline)
private void dl_walk(L)(L** head) {
	if (*head == null) {
		return;
	}

	auto le = *head;
	do {
		le = le.next;
	} while (le != *head);
}

pragma(inline)
private void dl_relink(L)(L* le, L** head_from, L** head_to)
		in(le.prev !is null && le.next !is null) {
	dl_unlink(le, head_from);
	dl_insertFront(le, head_to);
}

@("dl")
@safe unittest {
	struct LE {
		int p;
		LE* next;
		LE* prev;
	}

	LE* head1 = null;
	LE* head2 = null;
	auto le1 = new LE(1);
	auto le2 = new LE(2);
	dl_insertFront(le1, &head1);
	assert(head1 != null);
	dl_unlink(le1, &head1);
	assert(head1 == null);

	dl_insertFront(le1, &head1);
	assert(head1 != null);
	dl_insertFront(le2, &head1);
	dl_unlink(le1, &head1);
	assert(head1 != null);
	dl_unlink(le2, &head1);
	assert(head1 == null);

	dl_insertFront(le1, &head1);
	assert(head1 != null);
	dl_insertFront(le2, &head1);
	dl_unlink(le2, &head1);
	assert(head1 != null);
	dl_unlink(le1, &head1);
	assert(head1 == null);

	dl_insertFront(le1, &head1);
	dl_relink(le1, &head1, &head2);
	assert(head1 == null);
	assert(head2 != null);
}

///
/// This structure implements scheme 6.2 thom the
/// $(LINK http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf)
/// and supports several primitives:
/// $(UL
/// $(LI schedule timer in the future.)
/// $(LI cancel timer.)
/// $(LI time step (advance) - all timers expired at current time tick are extracted from wheels.)
/// )
/// Each operation take O(1) time.
///
struct TimingWheels(T) {
	import core.bitop : bsr;

	private {
		alias TimerIdType = ReturnType!(T.id);
		alias allocator = Mallocator.instance;

		enum MASK = 0xff;
		enum LEVELS = 8;
		enum LEVEL_MAX = LEVELS - 1;
		enum SLOTS = 256;
		enum FreeListMaxLen = 100;

		struct ListElement(T) {
			private {
				T timer;
				ulong scheduled_at;
				ushort position;
				ListElement!T* prev, next;
			}
		}

		struct Slot {
			ListElement!T* head;
		}

		struct Level {
			// now if counter of ticks processed on this level
			ulong now;
			Slot[SLOTS] slots;
		}

		Level[LEVELS] levels;
		ListElement!T* freeList;
		int freeListLen;
		HashMap!(TimerIdType, ListElement!T*) ptrs;
		long startedAt;
	}

	invariant {
		assert(freeListLen >= 0);
	}

	alias Ticks = ulong; // ticks are 64 bit unsigned integers.

	// hashing ticks to slots
	// 8 levels, each level 256 slots, with of slot on each level 256 times
	// translate ticks to level
	// 0x00_00_00_00_00_00_00_00 <- ticks
	//   ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓
	//   □  □  □  □  □  □  □  □ \
	//   □  □  □  □  □  □  □  □ |
	//   .  .  .  .  .  .  .  . | 256 slots
	//   .  .  .  .  .  .  .  . |
	//   □  □  □  □  □  □  □  □ /
	//   7  6  5  4  3  2  1  0
	//                          <- 8 levels
	// each slot - double linked list of timers

	// ticks to level = bsr(ticks)/8
	pragma(inline)
	private pure int t2l(ulong t) @safe @nogc nothrow {
		if (t == 0) {
			return 0;
		}

		return bsr(t) / LEVELS;
	}

	// ticks to slot  = ticks >> (level*8)
	pragma(inline)
	private pure int t2s(ulong t, int l) @safe @nogc nothrow {
		return (t >> (l << 3)) & MASK;
	}

	// level to ticks
	// l[0] -> 256
	// l[1] -> 256*256
	// ...
	pragma(inline)
	private pure ulong l2t(int l) @safe @nogc nothrow {
		return SLOTS << l;
	}

	~this() {
		ptrs.clear;
		for (int l = 0; l <= LEVEL_MAX; l++)
			for (int s = 0; s < SLOTS; s++) {
				while (levels[l].slots[s].head) {
					auto le = levels[l].slots[s].head;
					dl_unlink(le, &levels[l].slots[s].head);
					() @trusted {
						dispose(allocator, le);
					}();
				}
			}

		while (freeList) {
			assert(freeListLen > 0);
			auto n = freeList.next;
			() @trusted {
				dispose(allocator, freeList);
			}();
			freeListLen--;
			freeList = n;
		}
	}

	private ListElement!T* getOrCreate() {
		ListElement!T* result;
		if (freeList !is null) {
			result = freeList;
			freeList = freeList.next;
			freeListLen--;
			return result;
		}

		result = make!(ListElement!T)(allocator);
		return result;
	}

	private void returnToFreeList(ListElement!T* le) {
		if (freeListLen >= FreeListMaxLen) {
			// this can be safely disposed as we do not leak ListElements outide this module
			() @trusted {
				dispose(allocator, le);
			}();
		} else {
			le.position = 0xffff;
			le.next = freeList;
			freeList = le;
			freeListLen++;
		}
	}

	void initialize() {
		startedAt = Clock.currStdTime;
	}

	void initialize(ulong time) {
		startedAt = time;
	}

	/++ 
     + Return internal view on current time - it is time at the call to $(B init)
     + plus total number of steps multiplied by $(B tick) duration.
     + Params:
     +   tick = tick duration
     +/
	auto currStdTime(Duration tick) {
		return startedAt + levels[0].now * tick.split!"hnsecs".hnsecs;
	}

	///
	/// Schedule timer to $(B ticks) ticks forward from internal 'now'.
	///Params:
	/// timer = timer to schedule;
	/// ticks = ticks in the future to schedule timer. (0 < ticks < ulong.max);
	///Returns:
	///  void
	///Throws:
	/// ScheduleTimerError
	///   when thicks == 0
	///   or when timer already scheduled
	///
	bool schedule(T)(T timer, ulong ticks) {
		if (ticks == 0) {
			ticks = 1;
		}

		auto timer_id = timer.id();
		if (ptrs.contains(timer_id)) {
			return false;
		}

		size_t level_index = 0;
		long t = ticks;
		long s = 1; // width of the slot in ticks on level
		long shift = 0;
		while (t > s << 8) // while t > slots on level
		{
			t -= (SLOTS - (levels[level_index].now & MASK)) * s;
			level_index++;
			s = s << 8;
			shift += 8;
		}

		auto level = &levels[level_index];
		auto mask = s - 1;
		size_t slot_index =
			(level.now + (t >> shift) + ((t & mask) > 0 ? 1 : 0)) & MASK;
		auto slot = &levels[level_index].slots[slot_index];
		auto le = getOrCreate();
		le.timer = timer;
		le.position = ((level_index << 8) | slot_index) & 0xffff;
		le.scheduled_at = levels[0].now + ticks;
		dl_insertFront(le, &slot.head);
		ptrs[timer_id] = le;

		return true;
	}

	/// Cancel timer
	///Params:
	/// timer = timer to cancel
	///Returns:
	/// bool if timer was found and removed
	bool cancel(T)(T timer) {
		// get list element pointer
		auto v = ptrs.fetch(timer.id());
		if (!v.ok) {
			return false;
		}

		auto le = v.value;
		immutable level_index = le.position >> 8;
		immutable slot_index = le.position & 0xff;
		assert(timer is le.timer);
		debug(timingwheels)
			safe_tracef("cancel timer, l:%d, s:%d", level_index, slot_index);
		dl_unlink(le, &levels[level_index].slots[slot_index].head);
		returnToFreeList(le);
		ptrs.remove(timer.id());
		return true;
	}

	/// Number of ticks to rotate wheels until internal wheel 'now'
	/// catch up with real world realTime.
	/// Calculation based on time when wheels were stared and total
	/// numer of ticks pasded.
	///Params:
	/// tick = your tick length (Duration)
	/// realTime = current real world now (Clock.currStdTime)
	///Returns: ticks to advance so that we catch up real world current time
	int ticksToCatchUp(Duration tick, ulong realTime) {
		auto c = startedAt + tick.split!"hnsecs".hnsecs * levels[0].now;
		auto v = (realTime - c) / tick.split!"hnsecs".hnsecs;
		if (v > 256) {
			return 256;
		}

		return cast(int) v;
	}

	/// Time until next scheduled timer event.
	/// You provide tick size and current real world time.
	/// This function find ticks until next event and use time of the start and
	/// total steps executed to calculate time delta from $(B realNow) to next event.
	///Params:
	/// tick = your accepted tick duration.
	/// realNow = real world now, result of Clock.currStdTime
	///Returns: time until next event. Can be zero or negative in case you have already expired events.
	///
	Nullable!Duration timeUntilNextEvent(const Duration tick, ulong realNow) {
		assert(startedAt > 0, "Forgot to call init()?");
		if (totalTimers == 0)
			return typeof(return).init;
		immutable n = ticksUntilNextEvent();
		immutable target =
			startedAt + (levels[0].now + n) * tick.split!"hnsecs".hnsecs;
		auto delta = (target - realNow).hnsecs;
		return nullable(delta);
	}

	///
	/// Adnvance wheel and return all timers expired during wheel turn.
	//
	/// Params:
	///   ticks = how many ticks to advance. Must be in range 0 <= 256
	/// Returns: amount of ticks actually advanced
	///
	import std.array : Appender;
	ulong advance(this W)(ulong ticks, ref Appender!(T[]) app) {
		auto max = l2t(0);
		if (ticks > max) {
			ticks = max;
		}

		if (ticks == 0) {
			ticks = 1;
		}

		auto advanced = ticks;

		auto level = &levels[0];

		while (ticks) {
			ticks--;
			immutable now = ++level.now;
			immutable slot_index = now & MASK;
			auto slot = &level.slots[slot_index];
			//debug(timingwheels) safe_tracef("level 0, now=%s", now);
			while (slot.head) {
				auto le = slot.head;
				auto timer = le.timer;
				app.put(timer);
				dl_unlink(le, &slot.head);
				returnToFreeList(le);
				ptrs.remove(timer.id());
			}

			if (slot_index == 0) {
				advance_level(1);
			}
		}
		return advanced;
	}

	auto totalTimers() pure @safe @nogc {
		return ptrs.length();
	}

	//
	// ticks until next event on level 0 or until next wheel rotation
	// If you have empty ticks it is safe to sleep - you will not miss anything, just wake up
	// at the time when next timer have to be processed.
	//Returns: number of safe "sleep" ticks.
	//
	private int ticksUntilNextEvent() out(r; r <= 256) {
		int result = 1;
		auto level = &levels[0];
		immutable uint now = levels[0].now & MASK;
		auto slot = (now + 1) & MASK;
		//assert(level.slots[now].head == null);
		do {
			if (level.slots[slot].head != null) {
				break;
			}

			result++;
			slot = (slot + 1) & MASK;
		} while (slot != now);

		return min(result, 256 - now);
	}

	private void advance_level(int level_index) in(level_index > 0) {
		immutable now0 = levels[0].now;
		auto level = &levels[level_index];
		immutable now = ++level.now;
		immutable slot_index = now & MASK;
		auto slot = &level.slots[slot_index];
		while (slot.head) {
			auto listElement = slot.head;

			immutable delta = listElement.scheduled_at - now0;
			size_t lower_level_index = 0;
			long t = delta;
			size_t s = 1; // width of the slot in ticks on level
			size_t shift = 0;
			while (t > s << 8) // while t > slots on level
			{
				t -= (SLOTS - (levels[lower_level_index].now & MASK)) * s;
				lower_level_index++;
				s = s << 8;
				shift += 8;
			}

			auto mask = s - 1;
			size_t lower_level_slot_index = (levels[lower_level_index].now
				+ (t >> shift) + ((t & mask) > 0 ? 1 : 0)) & MASK;
			listElement.position =
				((lower_level_index << 8) | lower_level_slot_index) & 0xffff;
			dl_relink(
				listElement, &slot.head,
				&levels[lower_level_index].slots[lower_level_slot_index].head);
		}

		if (slot_index == 0 && level_index < LEVEL_MAX) {
			advance_level(level_index + 1);
		}
	}

	void reset() {
		this = TimingWheels!T();
	}
}

@("TimingWheels")
@safe unittest {
	import unit_threaded;
	import std.stdio;
	TimingWheels!Timer w;
	w.initialize();
	assert(w.t2l(1) == 0);
	assert(w.t2s(1, 0) == 1);
	immutable t = 0x00_00_00_11_00_00_00_77;
	immutable level = w.t2l(t);
	assert(level == 4);
	immutable slot = w.t2s(t, level);
	assert(slot == 0x11);
	auto timer = new Timer();
	import std.array : Appender;
	Appender!(Timer[]) timers;
	() @safe {
		w.schedule(timer, 2);
		assert(!w.schedule(timer, 5));
		assert(w.advance(1024, timers) == 256);
		w.cancel(timer);
		w.advance(1, timers);
	}();
}

@("TimingWheels.2")
@safe unittest {
	import unit_threaded;
	import std.stdio;
	TimingWheels!Timer w;
	auto timer = new Timer();
	import std.array : Appender;
	Appender!(Timer[]) timers;
	w.initialize();
	w.schedule(timer, 1);
	auto r = w.advance(1, timers);
	assert(timers.data.length == 1);
	timers.clear();
	w.schedule(timer, 256);
	r = w.advance(255, timers);
	assert(timers.data.length == 0);
	r = w.advance(1, timers);
	assert(timers.data.length == 1);
	timers.clear();
	w.schedule(timer, 256 * 256);
	int c;
	for (int i = 0; i < 256; i++) {
		r = w.advance(256, timers);
		c += timers.data.length;
		timers.clear();
	}

	assert(c == 1);
}

@("rt")
@safe unittest {
	import unit_threaded;
	TimingWheels!Timer w;
	Duration tick = 5.msecs;
	w.initialize();
	ulong now = Clock.currStdTime;
	assert(now - w.currStdTime(tick) < 5 * 10_000);
	now += (tick * 2).total!"hnsecs";
	assert((now - w.currStdTime(tick)) / 10_000 - (2 * tick).split!"msecs".msecs
		< 10);
	auto toCatchUp = w.ticksToCatchUp(tick, now);
	toCatchUp.shouldEqual(2);
	import std.array : Appender;
	Appender!(Timer[]) timers;
	auto t = w.advance(toCatchUp, timers);
	toCatchUp = w.ticksToCatchUp(tick, now);
	toCatchUp.shouldEqual(0);
}

@("cancel")
@safe unittest {
	import unit_threaded;
	TimingWheels!Timer w;
	w.initialize();
	Timer timer0 = new Timer();
	Timer timer1 = new Timer();
	w.schedule(timer0, 256);
	w.schedule(timer1, 256 + 128);
	import std.array : Appender;
	Appender!(Timer[]) timers;
	auto r = w.advance(255, timers);
	assert(timers.data.length == 0);
	w.cancel(timer0);
	r = w.advance(1, timers);
	assert(timers.data.length == 0);
	w.cancel(timer1);
}

@("ticksUntilNextEvent")
@safe unittest {
	import unit_threaded;
	import std.array : Appender;
	Appender!(Timer[]) timers;
	TimingWheels!Timer w;
	w.initialize();
	auto s = w.ticksUntilNextEvent;
	assert(s == 256);
	auto r = w.advance(s, timers);
	assert(timers.data.length == 0);
	Timer t = new Timer();
	w.schedule(t, 50);
	s = w.ticksUntilNextEvent;
	assert(s == 50);
	r = w.advance(s, timers);
	assert(timers.data.length == 1);
}
